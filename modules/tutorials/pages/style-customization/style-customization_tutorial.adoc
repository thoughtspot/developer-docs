= Visual Embed SDK Style Customization Tutorial
:page-pageid: style-customization__tutorial
:description: This is a self-guided course on style customization of the Visual Embed SDK components
:toc: true
:toclevels: 1

One of the main advantages of ThoughtSpot Embedded is the control over the styling and UI elements provided by the Visual Embed SDK.

This tutorial will walk through controlling the various essential aspects of UI and styling of embedded ThoughtSpot.

The aspects you can control are:

1. Large component elements
2. CSS styles
3. Text string and icon replacement
4. Menu items


== 01 - Getting started

This tutorial will use the Visual Embed SDK Playground built into every ThoughtSpot instance to give a live environment for trying the various customizations.

We suggest copying the code into a text editor or IDE such as Visual Studio Code to make it easier to work on the examples, then copy the values back into the code editor within the Playground.

We'll start by selecting a LiveboardEmbed component from the dropdown on the left:

image:images/tutorials/style-customization/choose-liveboard-embed.png[Choose LiveboardEmbed component]

Pick the "(Sample) Sales Performance" Liveboard, which should be available on any instance (including the Free Trial):

image:images/tutorials/style-customization/choose-liveboard.png[Choose Liveboard]

If you do not have "(Sample) Sales Performance" available, use any Liveboard that you have access to.

You should see code in the panel below the selector boxes, which you can copy at any point down to `.render();` :

[,javascript]
----
// Import ThoughtSpot SDK
import {
  init,
  LiveboardEmbed,
  Action,
  RuntimeFilterOp,
  EmbedEvent,
  AuthType,
  HostEvent
} from "@thoughtspot/visual-embed-sdk";
import "./styles.css";
import { getTokenService } from "./tokenService";
  
// Use prefetch to load static resources early and optimize response time. 
// Call init early to complete authentication during app load for better performance.
init({
  thoughtSpotHost:
    /*param-start-hosturl*/"https://embed-1-do-not-delete.thoughtspotstaging.cloud"/*param-end-hosturl*/,
/*param-start-styleCustomization*//*param-end-styleCustomization*/
  authType: AuthType.TrustedAuthTokenCookieless,
  getAuthToken: getTokenService,
  disableTokenVerification: true,
});

// Instantiate class for embedding a Liveboard
const embed = new LiveboardEmbed("#your-own-div", {
    frameParams: {},
    /*param-start-liveboardId*/
     liveboardId: "d084c256-e284-4fc4-b80c-111cb606449a",
/*param-end-liveboardId*/
/*param-start-activeTabId*//*param-end-activeTabId*/
/*param-start-liveboardFullHeight*//*param-end-liveboardFullHeight*/
/*param-start-customizeLiveboardHeader*//*param-end-customizeLiveboardHeader*/
/*param-start-hideLiveboardHeader*//*param-end-hideLiveboardHeader*/
/*param-start-runtimeFiltersAndParameters*//*param-end-runtimeFiltersAndParameters*/
/*param-start-modifyActions*//*param-end-modifyActions*/
});

hideNoDataImage();
showErrorBanner('none');

embed
    // Register event listeners
    .on(EmbedEvent.Init, showLoader)
    .on(EmbedEvent.Load, hideLoader)
    /*param-start-customActionHandle*//*param-end-customActionHandle*/
    .on(EmbedEvent.Error, (error) => {
        if(error?.data?.errorType === 'FULLSCREEN') {
          showErrorBanner('none');
        } else 
        if(typeof(error.error) === 'string') {
          showErrorBanner('flex', error.error);
        } else {
          showErrorBanner('flex');
        }
        console.log('Error ', error);
        hideLoader();
    })
    // Render Liveboard
    .render();
----

== 02 - Large component elements

The checkboxes above the code panel provide quick access to the code to do many elements.

Click the checkbox for `Customize Liveboard header` and the following code block will appear:

[,javascript]
----
 /* Show or hide the liveboard title and description */
 showLiveboardTitle: true,
 showLiveboardDescription: true,
 // isLiveboardHeaderSticky: false, /* Removes the header stickiness when scrolling if set to false */
 // hideLiveboardHeader: true, /* Hides the entire liveboard header */

 /* Customize display of tabs in the liveboard header */
 // hideTabPanel: true, /* Removes the tab panel */
 // visibleTabs:['TabId'], /* Remove all tabs if empty array*/
 // hiddenTabs:['TabId'],
 /* Use either visibleTabs or hiddenTabs */
----

Note there are a number of examples that are commented out using the `//` line comment. You can remove any of these to enable and try the results.

Press the `Run` button to see the LiveboardEmbed component load to the left with the new options.

Now uncomment `hideLiveboardHeader: true` by removing the `//` in front.

Press the `Run` button again to see the updated results.

=== Available component element configurations
There are many more configurations available for each component than are easily chosen within the Playground.

To see all of the available options, you'll need to look at the `Visual Embed SDK Reference`, at the `{Component}ViewConfig` documentation under `Embed components`:

image:images/tutorials/style-customization/embed-components-reference.png[Components reference]

If we wanted to use something that is not automatically generated by the Playground, simply go to its link:https://developers.thoughtspot.com/docs/Interface_LiveboardViewConfig[definition within the reference page^] and look at the example code.

Click on *link:https://developers.thoughtspot.com/docs/Interface_LiveboardViewConfig#_locale[locale^]*, which allows you to override any of the user's locale settings.

Copy the property into the code in the Playground and chose a valid locale code ('fr' or 'it' will work):

[,javascript]
----
 /* We added this one ourselves */
 locale: 'fr',
 /* Show or hide the liveboard title and description */
 showLiveboardTitle: true,
 showLiveboardDescription: true,
 // isLiveboardHeaderSticky: false, /* Removes the header stickiness when scrolling if set to false */
 // hideLiveboardHeader: true, /* Hides the entire liveboard header */

 /* Customize display of tabs in the liveboard header */
 // hideTabPanel: true, /* Removes the tab panel */
 // visibleTabs:['TabId'], /* Remove all tabs if empty array*/
 // hiddenTabs:['TabId'],
 /* Use either visibleTabs or hiddenTabs */
----

Press the `Run` button and try some of the menu system once the Liveboard has loaded up:

image:images/tutorials/style-customization/locale-override.png[Locale override property]


=== Hiding elements without configuration options
If there are elements of the page that you can't find an option to hide in the configruation options, you may need to use the CSS customization framework to hide a given element directly. 

This will be covered in the CSS styles portion of the tutorial. If you find you need to do this, please let ThoughtSpot know what element you would like to have a configuration option for by submitting an idea to the link:https://community.thoughtspot.com/s/ideas[ThoughtSpot Community^].

== 03 - CSS styles
The Visual Embed SDK has a `customizations` framework for adding CSS and other overrides.

In the Playground, click the checkbox next to `Apply custom styles`.

[NOTE]
====
The `customizations` section goes in the `init()` function options object, whereas almost all other customizations happen in the component initializer.
====

A large block of code is generated, showing the variety of ways you can specify CSS customizations:

[,javascript]
----
customizations: {
  style: {
    customCSSUrl: "https://cdn.jsdelivr.net/gh/thoughtspot/custom-css-demo/css-variables.css", // location of your style sheet

    // To apply overrides for your style sheet in this init, provide variable values below, eg
    customCSS: {
      variables: {
        "--ts-var-button--secondary-background": "#F0EBFF",
        "--ts-var-button--secondary--hover-background": "#E3D9FC",
        "--ts-var-root-background": "#F7F5FF",
      },
    },
  },
},
----

=== Variables and selectors
ThoughtSpot provides a large number of pre-defined xref:customize-css-styles.adoc[CSS variables] for controlling the styling of major elements throughout the embedded components UI.

These can all be declared directly within the `variables` block inside the `customCSS` block.

The customization framework also allows using any CSS selector to target specific elements with changes that do not have a defined variable.

Selectors are declared within the `rules_UNSTABLE` block inside `customCSS`, reflecting that specific selectors may change with new releases as elements of ThoughtSpot are updated.

Let's add a selector to the code in our Playground. First, comment out the `customCSSUrl` line, then add the `rules_UNSTABLE` block below `variables`:
[,javacript]
----
customizations: {
  style: {
    // customCSSUrl: "https://cdn.jsdelivr.net/gh/thoughtspot/custom-css-demo/css-variables.css", // location of your style sheet

    // To apply overrides for your style sheet in this init, provide variable values below, eg
    customCSS: {
      variables: {
        "--ts-var-button--secondary-background": "#F0EBFF",
        "--ts-var-button--secondary--hover-background": "#E3D9FC",
        "--ts-var-root-background": "#F7F5FF",
      },
      rules_UNSTABLE: {

      }
    },
  },
},
----

Variables declare a *single* property, so are simply `"{var-name}" : "{value}"`, but selectors can define any number of properties to assign to the selected elements.

[NOTE]
====
Selectors apply properties to elements with many layers of styling. Always add `!important` after each property to ensure the browser overrides whatever other style rules may be applied for the same property.
====

One use case of `rules_UNSTABLE` section is `xref:css-customization.adoc#font-declarations[@font-face]` declarations, which by their nature have many properties for one selector.

We will switch the main font to `link:https://fonts.google.com/specimen/Poppins[Poppins^]`, available from Google Fonts.

First, add the `--ts-var-root-font-family` variable to declare the new font (note you'll need to use this exact name value in `@font-face` declarations).

Next we'll add a selector block within the `rules_UNSTABLE` block (see the xref:css-customization.adoc#font-declarations[documentation] to understand how we found these properties): 

[,javacript]
----
...
    customCSS: {
      variables: {
        "--ts-var-button--secondary-background": "#F0EBFF",
        "--ts-var-button--secondary--hover-background": "#E3D9FC",
        "--ts-var-root-background": "#F7F5FF",
        "--ts-var-root-font-family": "Poppins"
      },
      rules_UNSTABLE: {
        '/* ff-400 */ @font-face': {
          'font-family': "Poppins",
          'font-style': 'normal',
          'font-weight': '400',
          'font-display': 'swap',
          'src': "url(https://fonts.gstatic.com/s/poppins/v21/pxiEyp8kv8JHgFVrJJfecnFHGPc.woff2) format('woff2')"
      }
      }
    },
  },
},
----

Notice the format is the *selector* as the *key*, then an object block containing individual key-value pairs for the properties.

Because the *selector* is an *object key*, but all `@font-face` declarations start the same way, we add a *unique CSS comment* at the beginning to allow for multiple `@font-face` declarations.

If you press `Run` in the Playground, you should now see the Liveboard reload with the Poppins font for most of the text.


=== CSS files
You can collect a set of variables and selectors into a CSS file, rather than declaring them in the JavaScript code block.

CSS files can be included from domain but they must be added to the `CSP style-src domains` and `CSP font-src` domains in the `Develop` -> `Customizations` -> `Security settings`. 

Both `https://cdn.jsdelivr.net` and `https://fonts.gstatic.com` are always automatically part of ThoughtSpot's CSP allow list.

Global variables should be declared in the `:root { }` block of the CSS file, while `@font-face` declarations of a named font can be placed anywhere:

[,css]
----
:root {
  --ts-var-button--primary-background: #2359B6;
  --ts-var-button--primary--hover-background: blue;
  --ts-var-button--primary--font-family: Poppins,Helvetica,Arial,sans-serif;;
}

@font-face {
  font-family: 'Poppins';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: url(https://fonts.gstatic.com/s/poppins/v21/pxiEyp8kv8JHgFVrJJfecnFHGPc.woff2) format('woff2');
}

.bk-filter-option {
  display: none!important;
}
----

=== Hiding elements
As seen in the CSS file example above, one of the use cases for selectors is to *hide* embed component elements that do not have a configuration option. 

`display: none!important` is the most typical property to accomplish this, but you may choose any CSS rule that causes the desired effect.

Make sure that the selector you use is specific and isn't affecting other elements that you don't intend to hide.

Please link:https://community.thoughtspot.com/s/ideas[contact ThoughtSpot^] if you find yourself hiding certain elements via CSS selectors, so that the overall configurations can be expanded over time. Similarly, provide feedback on properties that variables are unavailable by submitting an idea to the link:https://community.thoughtspot.com/s/ideas[ThoughtSpot Community^].

== 04 - Text strings and icon replacement
The `customizations` object has the ability to specific xref:customize-text-strings.adoc[text string] and xref:customize-icons.adoc[icon replacement], along with the CSS framework.

Let's add the `content` property with a block above the `style` property in the Playground, and the `strings` property block within it. Now we can declare exact text elements to replace within ThoughtSpot:

[,javacript]
----
...
customizations: {
  content: {
     strings: {
         "Liveboard": "Dashboard",
         "SpotIQ": "Insights",
         "Spotter": "AI Agent"
     }
  },
  style: {
   ...
  },
},
----

Icon sprite replacement requires creating a file of SVG icon definitions, the format for which is available in the are xref:customize-icons.adoc[documentation].  

Once you have the SVG file saved and accessible to ThoughtSpot, the `iconSpriteUrl` property under the `customizations` block is all that is needed:

[,javacript]
----
...
customizations: {
 iconSpriteUrl: "https://cdn.jsdelivr.net/gh/thoughtspot/custom-css-demo/icon-override1.svg",
 content: {
     strings: {
         "Liveboard": "Dashboard",
         "SpotIQ": "Insights",
         "Spotter": "AI Agent"
     }
  },
  style: {
   ...
  },
},
----

== 05 - Menu items
ThoughtSpot menus are accesible in the top right corner with the *...* icon or via a right-click on an axis or data point.

On a Liveboard, there is a liveboard level top menu as well as individual viz level top menus.

The menu from right-clicking a data point is referred to as the *Context Menu*. 

=== Hiding or disabling items
Individual menu items are controlled by their capabilities, which are referred to as *Actions*. 

The Visual Embed SDK reference guide for link:https://developers.thoughtspot.com/docs/Enumeration_Action[Actions^] contains the complete list of named capabilities. 

In the Playground, click the checkbox for `Modify available actions`, and the following code will be added automatically:

[,javascript]
----
disabledActions: [],
disabledActionReason: "Reason for disabling",
// visibleActions: [], /* Removes all actions if empty array */
hiddenActions: [],
/* Use either visibleActions or hiddenActions */
----

If we only want to show a small set of menu items, we can uncomment `visibleActions` (an allow list) and comment out `hiddenActions` (a deny list).

Let's only show the `DownloadAsPdf` Action:

[,javascript]
----
disabledActions: [],
disabledActionReason: "Reason for disabling",
visibleActions: [Action.DownloadAsPdf], /* Removes all actions if empty array */
//hiddenActions: [],
/* Use either visibleActions or hiddenActions */
----

When you press `Run`, the top level Liveboard menu will reload with only the single menu item specified in the `visibleActions` array.

[NOTE]
====
There is no longer a right-click *context menu* in the above example, because all of the *Actions* that would appear there (such as `Action.DrillDown`) are also hidden.
====

The `disabledActions` array keeps the item in the menu but grays it out, with the `disabledActionReason` appearing when hovering over the menu item.

=== Triggering hidden menu items with HostEvents
ThoughtSpot Visual Embed SDK defines two types of events: *link:https://developers.thoughtspot.com/docs/Enumeration_EmbedEvent[EmbedEvents^]* for listening to actions within ThoughtSpot components and *link:https://developers.thoughtspot.com/docs/Enumeration_HostEvent[HostEvents^]* to send messages to the ThoughtSpot components from the embedding application. 

If a menu item has been hidden, you can still send in a *HostEvent* to cause the same behavior.

Check the box next to `Use Host Event` above the code editor in the Playground and this code block will be added:

[,javascript]
----
 document.getElementById('tryBtn').addEventListener('click', e => {
      // Trigger events can be added here to bind to try button click!
      // eg use the Reload Event so that clicking on "Try event" button reloads the embed:
      embed.trigger(HostEvent.Reload);
 });
----

If you look at the top right of the "Stax" app, to the left of the user icon, there is a `Try Event` button. The code block adds a click event to this button, within which we can *trigger* any *HostEvent*.

Let's replace the default `Reload` event with `DownloadAsPdf`:

[,javascript]
----
 document.getElementById('tryBtn').addEventListener('click', e => {
      // Trigger events can be added here to bind to try button click!
      // eg use the Reload Event so that clicking on "Try event" button reloads the embed:
      embed.trigger(HostEvent.DownloadAsPdf);
 });
----

Testing this requires two steps:

1. Press `Run` button to reload the entire *Stax* embedded tester app
2. Press the `Try Event` button

You should see the PDF export modal dialog button pop up within the embedded component area.

If you do not want the modal dialog to appear, you could instead use the ThoughtSpot REST API to accomplish the task either within the browser or in a back-end process. This allows for choosing vastly different behaviors than those that are allowed by the ThoughtSpot modal dialogs.

=== Adding new menu items with Custom Actions
ThoughtSpot allows you to add new items to the menu system, called *xref:custom-actions.adoc[Custom Actions]*, both to the top menu for a given viz on a Liveboard or in the context menu when a single point is right-clicked.

*Callback custom actions* require a three-part setup:

1. Define the *Custom Action* within ThoughtSpot, with a particular *id*
2. Assign the *Custom Action* to the viz
3. Add a `EmbedEvent.CustomAction` listener within the Visual Embed SDK code

If you click the checkbox next to `Handle custom actions`, you'll see the following code block added:

[,javascript]
----
 .on(EmbedEvent.CustomAction, payload => {
      const customActionId = 'insert Custom Action ID here';
      if (payload.id === customActionId || payload.data.id === customActionId) {
           console.log('Custom Action event:', payload.data);
      }
 })
----

There are additional *link:https://developers.thoughtspot.com/docs/Enumeration_EmbedEvent[EmbedEvents^]* such as `VizPointClick` that fire off without involving the menu system that work similarly to context menu custom actions.

== 06 - Conclusion

This tutorial has covered how to start with the majority of capabilities used to customize the UI and UX of ThoughtSpot's embedded components, but only within the Visual Embed SDK Playground.

The next steps are to move this code into the pages of your own application and configure the CSP and CORS settings for your application's test environments, so you begin integrating ThoughtSpot directly into your application.
