= Pre-rendering ThoughtSpot Embed Components
:toc: true
:toclevels: 3

:page-title: Pre-rendering for Fast Embeds
:page-pageid: prerender
:page-description: How to use pre-rendering to optimize performance and user experience in ThoughtSpot embedding

== Load Flow Diagrams

The following diagrams illustrate how ThoughtSpot embed components load in a typical application, both for normal and pre-rendered scenarios. Reviewing these will help set the context for the strategies described in this guide.

=== Basic Embed Load Flow

When a ThoughtSpot embed loads, it goes through several distinct phases:

image::./images/pre-render/dig1.1.png[]

In the diagram above, each block represents a step in the embed loading process, and each block takes time to complete. The ThoughtSpot embed loading process consists of:

1. **Host App Load** - Your application initializes and loads
2. **Init** - ThoughtSpot SDK initialization and login.
3. **ThoughtSpot Embed Loads** - The load time taken for the embed to load.

image::./images/pre-render/dig1.2.png[]

As shown in the detailed diagram above, each block represents a distinct step that takes time to execute. The ThoughtSpot embed load process can be further broken down into the following phases:
  
* **Common Asset Load** – Loading shared JavaScript and CSS files
* **Common Bootstrap** – Setting up the basic embed framework
* **Embed Level Asset Load** – Loading specific assets for the embed type
* **Embed API Calls** – Fetching data and rendering the content

=== Optimized Load Flow with Early Init

For applications that have a loading screen or home page before the liveboard embed, you can optimize performance by calling init in parallel:

image::./images/pre-render/dig2.png[]

This diagram shows how you can start the authentication/login process early by calling init while the end user is still on the home page or loading screen. Note that this only handles the login process in parallel - no assets are loaded during this phase.

== How Embedding Normally Works (The Basics)

When you embed ThoughtSpot in your application, the typical flow is:

. Call init (authentication/SDK initialization)
. Render the embed component
. Embed loads the iframe
. Iframe loads assets, calls APIs, and shows the analytics

This means *every time* an end user visits the page, the iframe and all assets are loaded from scratch, causing a visible delay before analytics appear.

== What is Pre-rendering?

Pre-rendering changes this flow by *loading some or all of the assets and initialization steps in the background*, before the end user actually navigates to the analytics. This way, when the end user visits the page, the analytics are ready to show instantly (or much faster).

You can preload just the common assets, or even a specific liveboard, depending on your needs. This doc explains the different pre-render strategies, when to use each, and how to implement them in React or JavaScript.

[NOTE]
====
Pre-rendering is most effective when your application has a loading page, landing page, or pre-embed page where you can start the pre-render process before the end user navigates to the analytics. If an end user navigates directly to the embed page (for example, via a direct link or bookmark), pre-rendering cannot provide a speed benefit because there is no opportunity to load assets in advance.
====

== Why Pre-render?

* Reduce wait times for embedded analytics
* Improve perceived performance and user experience
* Choose the right tradeoff between speed and resource usage

== Embed Load Strategies

=== 1. Prerender with Liveboard ID

- Fully loads the embed iframe, including all assets and liveboard data, as soon as the component is rendered.
- Fastest experience for a specific liveboard.
- Maximum resource usage if the end user never views the embed.

image::./images/pre-render/dig3_pre_with_livid.png[]

To use this strategy, place the following component on your application's home page, loading page, or landing page (before the end user navigates to the analytics):

[source,jsx]
----
<PreRenderedLiveboardEmbed
  liveboardId="e40c0727-01e6-49db-bb2f-5aa19661477b"
  preRenderId="pre-render-with-liveboard-id"
/>
----

The value of `preRenderId` can be any string, but it must match the `preRenderId` you use when rendering the actual embed later.

[NOTE]
====
Limitation: Any props you want to pass to the embed (such as configuration options) must be passed to the `PreRenderedLiveboardEmbed` component on the home page. If you later render a `LiveboardEmbed` with the same `preRenderId`, those new props will not be respected if the iframe is already loaded. This is a current limitation of the pre-rendering approach.
====

When you actually want to show the liveboard, call this component:

[source,jsx]
----
<LiveboardEmbed
  preRenderId="pre-render-with-liveboard-id"
  liveboardId="e40c0727-01e6-49db-bb2f-5aa19661477b"
/>
----

=== 2. Prerender without Liveboard ID

- Loads common assets and bootstrap logic early.
- Defers liveboard-specific data/API calls until needed.
- Keeps the app ready, making the first liveboard load faster.
- Still loads some assets even if the end user never opens the embed.

image::./images/pre-render/dig4_wo_livid.png[]

To use this strategy, place the following component on your application's home page, loading page, or landing page (before the end user navigates to the analytics):

[source,jsx]
----
<PreRenderedLiveboardEmbed
  preRenderId="pre-render-without-liveboard-id"
/>
----

The value of `preRenderId` can be any string, but it must match the `preRenderId` you use when rendering the actual embed later.

[NOTE]
====
Limitation: Any props you want to pass to the embed must be passed to the `PreRenderedLiveboardEmbed` component on the home page. If you later render a `LiveboardEmbed` with the same `preRenderId`, those new props will not be respected if the iframe is already loaded.
====

When you actually want to show the liveboard, call this component:

[source,jsx]
----
<LiveboardEmbed
  preRenderId="pre-render-without-liveboard-id"
  liveboardId="e40c0727-01e6-49db-bb2f-5aa19661477b"
/>
----

=== 3. Prerender On Demand

- Loads nothing up front; the embed is loaded only when the end user navigates to it.
- On first visit, the embed loads normally; on return, the iframe is reused and appears instantly.
- Most efficient; only loads if needed, and reuses the iframe for instant reloads.

image::./images/pre-render/dig5_ondemand.png[]

When you render a component with a `preRenderId` for the first time, it loads as usual. The next time you render a component with the same `preRenderId`, the load is instant because the iframe is reused.

This strategy does not require special configuration—simply pass a `preRenderId` prop to your normal component render:

[source,jsx]
----
<LiveboardEmbed preRenderId="pre-render-on-demand" />
----

=== 4. Normal Render

- Default behavior; loads the embed only when the component is rendered.
- On every visit, the iframe is recreated and the embed loads from scratch.
- Efficient if the embed is rarely used, but slow for the end user every time.

image::./images/pre-render/dig2.png[]

[example]
----
<LiveboardEmbed liveboardId="some-liveboard-id" />
----

=== 5. Prefetch Assets

- Loads a few common JS/CSS assets in parallel with your app.
- No liveboard data or API calls are made.
- Minimal benefit (modern browsers cache these assets anyway).
- Wastes bandwidth if the end user never opens the embed.

image::./images/pre-render/dig6_prefetch.png[]

[NOTE]
====
As modern browsers already cache static assets efficiently, using prefetch may not provide a significant performance gain.
====

.Example: Prefetching assets
[source,js]
----
import {
   prefetch,
   PrefetchFeatures
} from '@thoughtspot/visual-embed-sdk';

prefetch("https://<hostname>:<port>", [
  PrefetchFeatures.LiveboardEmbed,
  PrefetchFeatures.VizEmbed
]);

init({
  thoughtSpotHost: "https://<hostname>:<port>",
  authType: AuthType.None,
});
----

== Strategy Comparison Table

[cols="1,1,1,1,1,1,2",options="header"]
|===
| Strategy | Loads in Parallel | Loads Data If Not Used | Loads Assets If Not Used | Reuses Iframe | Perceived Load Speed | Notes
| Normal Render | ❌ | ✅ No | ✅ No | ❌ | ❌ Slowest | No reuse; re-renders every time
| Prefetch | ✅ (few assets) | ✅ No | ⚠️ Yes (small assets) | ❌ | ⚠️ Slight improvement | Browser cache often makes it redundant
| Prerender + ID | ✅ | ❌ Yes | ❌ Yes | ✅ | ✅✅✅ Fastest | Best UX, worst resource efficiency
| Prerender w/o ID | ✅ | ✅ No | ⚠️ Yes (partial assets) | ✅ | ⚠️ Moderate | Trade-off between prep and efficiency
| On Demand | ❌ | ✅ No | ✅ No | ✅ | ✅ (on revisit), ❌ (first visit) | Best balance of performance and efficiency
|===

== How to Implement Pre-rendering

You can use pre-rendering in both standard JavaScript and React. Here are the key methods and properties from the Visual Embed SDK:

[cols="1,2,2",options="header"]
|===
| Method/Property | Description | Example
| preRender() | Creates a pre-render shell | `await embed.preRender();`
| prerenderGeneric() | Pre-renders a generic instance | `await embed.prerenderGeneric();`
| showPreRender() | Displays the pre-rendered component | `await embed.showPreRender();`
| hidePreRender() | Hides the pre-rendered component | `embed.hidePreRender();`
| getPreRenderIds() | Gets unique HTML element IDs for pre-render elements | `embed.getPreRenderIds();`
| preRenderId | Config property for the pre-rendered instance | `preRenderId: "preRenderId-123"`
| syncPreRenderStyle() | Syncs style/position/size with the embedding element | `embed.syncPreRenderStyle();`
| doNotTrackPreRenderSize | Disables dynamic size tracking | `doNotTrackPreRenderSize: true`
|===

== Troubleshooting

* If the pre-rendered component does not appear, check that the container is visible and coordinates are set.
* Ensure you are not re-creating the embed instance on every render in React.

== Additional Resources

* link:https://github.com/thoughtspot/developer-examples/tree/main/visual-embed/pre-rendering[Pre-rendering examples on GitHub]
* link:https://codesandbox.io/p/sandbox/github/thoughtspot/developer-examples/tree/main/visual-embed/pre-rendering[CodeSandbox: Pre-rendering]

