= Pre-rendering ThoughtSpot Embed Components
:toc: true
:toclevels: 3

:page-title: Pre-rendering for Fast Embeds
:page-pageid: prerender
:page-description: How to use pre-rendering to optimize performance and user experience in ThoughtSpot embedding

== Getting Started: How Does Embedding Work ?

Before diving into pre-rendering, it's important to understand how embedding ThoughtSpot works in a typical web application.

ThoughtSpot is a web app, and like any modern web application, it requires two main things to function:

*Assets*: These are the static files your browser needs to display and run the application, such as JavaScript files, CSS files, fonts, and images.

*API Calls*: These are network requests made from the browser to the ThoughtSpot backend to fetch:

- Data (the actual analytics, tables, charts, etc)
- Metadata (information about users, tables, permissions, etc)

TODO: basic for dig

When you embed ThoughtSpot in your application, the browser must first download all the necessary assets. Once these files are loaded, the application runs its JavaScript code, which then makes API calls to fetch the data and metadata needed to render analytics for the user.

== How ThoughtSpot Optimizes Asset and API Loading

ThoughtSpot internally optimizes the loading process by splitting assets and API calls, so that only the files and data needed for a specific component are loaded when required. This means:

- For different embed components like Search, Liveboard, and Spotter, only the assets and API calls required for that component are loaded.
- There are a few common assets (such as fonts, shared JavaScript, and CSS) and common API calls (like user info) that are always loaded, as they are used across all embed types.
- In addition to these common resources, each component (for example, Liveboard) will load its own specific JavaScript, CSS, and make API calls only needed for that component.

TODO: basic for asset splitting diagram

For example, if you are embedding a Liveboard:
- The browser will first load the common assets and make common API calls (such as fonts and user info).
- Then, it will load the Liveboard-specific JavaScript and CSS files, and make the API calls needed to fetch Liveboard data.
- Assets and API calls for other components, like Search or Spotter, are not loaded unless those components are actually used.

This approach ensures that the embed is efficient, loading only what is necessary for the user's current experience, and helps improve performance by reducing unnecessary downloads and network requests.

Before we dive deeper into pre-rendering, let's understand the essential first step in embedding ThoughtSpot.

== About `init`: The Essential First Step

Before you can render any ThoughtSpot embed component, you must call the `init` method from the Visual Embed SDK. This function initializes the SDK and sets up the connection to your ThoughtSpot instance. It is the required starting point for any embedding scenario.

**When should you call `init`?**
- Call `init` as early as possible in your application lifecycle—ideally on your app’s initial load, landing page, or loading screen.
- The `init` call is very lightweight: it does not trigger heavy asset downloads or make many API calls. Therefore, there is no downside to calling it early, and it ensures that subsequent embed loads are as fast as possible.

TODO: basic dig for init

**Summary:** Always call `init` before rendering any embed component, and do so as soon as your app loads.

== Introducing Pre-rendering

Now that you understand how ThoughtSpot loads assets and data, let’s discuss how you can make things even faster for your users.

Imagine this scenario:

You have an app with a landing screen where users spend some time before navigating to the _embedded analytics page_ (where ThoughtSpot is embedded). In the current setup, ThoughtSpot only starts loading when the user actually visits the analytics page.

But what if you could start loading some of ThoughtSpot’s necessary files and data even before the user gets to the analytics page—while they’re still on the landing screen?


That’s exactly what pre-rendering does! By starting the load process early, you can make the analytics appear much faster when the user finally navigates to that page.

TODO: basic for dig for pre-rendering intro


=== Key Terms Used in This Guide

Keeping the above in mind, let's define a few key terms that we'll use later in this guide:

* **Common Asset Download** – The shared JavaScript and CSS files that every embed needs
* **Common API Calls** – The basic API requests made for things like user info, used by all embed types
* **Embed Level Asset Download** – The specific files (like JS and CSS) needed only for the embed type you're using (for example, Liveboard or Search)
* **Embed API Calls** – The API requests made to fetch the actual data and content for the specific embed (like loading a Liveboard's data)
* **Host app** – This is your web application (the main app your users interact with)
* **Analytics page** – This is a page in your web app where ThoughtSpot is actually embedded



== How to use pre-rendering?

Based on your use case, you can choose to pre-render the embed in one of the following ways:


=== 1. Pre-render with liveboard id

In this approach, you load everything all at once. When the user navigates to the analytics page, the embed is already loaded and ready to show.

- Fully loads the embed iframe, including all assets and liveboard data, as soon as the component is rendered.
- Fastest experience for a specific liveboard. 
- Maximum resource usage if the end user never views the embed.

image::./images/pre-render/dig3_pre_with_livid.png[]

==== How to implement this approach ?

In your application's home page, loading page, or landing page, you need to PreRender the embed with the liveboard id.

[source,jsx]
----
// React
<PreRenderedLiveboardEmbed
  liveboardId="e40c0727-01e6-49db-bb2f-5aa19661477b"
  preRenderId="pre-render-with-liveboard-id"
/>
----

OR

[source,js]
----
// JavaScript
import { LiveboardEmbed } from '@thoughtspot/visual-embed-sdk';

const embed = new LiveboardEmbed({
  liveboardId: 'e40c0727-01e6-49db-bb2f-5aa19661477b',
  preRenderId: 'pre-render-with-liveboard-id',
});

embed.preRender();
----

The value of `preRenderId` can be any string, but it must match the `preRenderId` you use when rendering the actual embed later.

When you actually want to show the liveboard, call this component:

[source,jsx]
----
// React
<LiveboardEmbed
  preRenderId="pre-render-with-liveboard-id"
  liveboardId="e40c0727-01e6-49db-bb2f-5aa19661477b"
/>
----

OR

[source,js]
----
// JavaScript
import { LiveboardEmbed } from '@thoughtspot/visual-embed-sdk';

const embed = new LiveboardEmbed({
  liveboardId: 'e40c0727-01e6-49db-bb2f-5aa19661477b',
  preRenderId: 'pre-render-with-liveboard-id',
});

embed.render();
----


[NOTE]
====
Limitation: Any properties you want to pass to the embed (such as configuration options) must be passed to the `PreRenderedLiveboardEmbed` component on the home page. If you later render a `LiveboardEmbed` with the same `preRenderId`, those new props will not be respected if the iframe is already loaded. This is a current limitation of the pre-rendering approach.
====

This approach is the fastest way to load the embed, but it is also the most resource-intensive.
The makes calls to the ThoughtSpot API to fetch the liveboard data and metadata, which might be unwanted if the end user never views the embed.


=== 2. Pre-render without liveboard id


- Loads common assets and bootstrap logic early.
- Defers liveboard-specific data/API calls until needed.
- Keeps the app ready, making the first liveboard load faster.
- Still loads some assets even if the end user never opens the embed.

image::./images/pre-render/dig4_wo_livid.png[]

To use this strategy, place the following component on your application's home page, loading page, or landing page (before the end user navigates to the analytics):

[source,jsx]
----
<PreRenderedLiveboardEmbed
  preRenderId="pre-render-without-liveboard-id"
/>
----

The value of `preRenderId` can be any string, but it must match the `preRenderId` you use when rendering the actual embed later.

[NOTE]
====
Limitation: Any props you want to pass to the embed must be passed to the `PreRenderedLiveboardEmbed` component on the home page. If you later render a `LiveboardEmbed` with the same `preRenderId`, those new props will not be respected if the iframe is already loaded.
====

When you actually want to show the liveboard, call this component:

[source,jsx]
----
<LiveboardEmbed
  preRenderId="pre-render-without-liveboard-id"
  liveboardId="e40c0727-01e6-49db-bb2f-5aa19661477b"
/>
----

=== 3. Prerender On Demand

- Loads nothing up front; the embed is loaded only when the end user navigates to it.
- On first visit, the embed loads normally; on return, the iframe is reused and appears instantly.
- Most efficient; only loads if needed, and reuses the iframe for instant reloads.

image::./images/pre-render/dig5_ondemand.png[]

When you render a component with a `preRenderId` for the first time, it loads as usual. The next time you render a component with the same `preRenderId`, the load is instant because the iframe is reused.

This strategy does not require special configuration—simply pass a `preRenderId` prop to your normal component render:

[source,jsx]
----
<LiveboardEmbed preRenderId="pre-render-on-demand" />
----

=== 4. Normal Render

- Default behavior; loads the embed only when the component is rendered.
- On every visit, the iframe is recreated and the embed loads from scratch.
- Efficient if the embed is rarely used, but slow for the end user every time.

image::./images/pre-render/dig2.png[]

[example]
----
<LiveboardEmbed liveboardId="some-liveboard-id" />
----

=== 5. Prefetch Assets

- Loads a few common JS/CSS assets in parallel with your app.
- No liveboard data or API calls are made.
- Minimal benefit (modern browsers cache these assets anyway).
- Wastes bandwidth if the end user never opens the embed.

image::./images/pre-render/dig6_prefetch.png[]

[NOTE]
====
As modern browsers already cache static assets efficiently, using prefetch may not provide a significant performance gain.
====

.Example: Prefetching assets
[source,js]
----
import {
   prefetch,
   PrefetchFeatures
} from '@thoughtspot/visual-embed-sdk';

prefetch("https://<hostname>:<port>", [
  PrefetchFeatures.LiveboardEmbed,
  PrefetchFeatures.VizEmbed
]);

init({
  thoughtSpotHost: "https://<hostname>:<port>",
  authType: AuthType.None,
});
----

== Strategy Comparison Table

[cols="1,1,1,1,1,1,2",options="header"]
|===
| Strategy | Loads in Parallel | Loads Data If Not Used | Loads Assets If Not Used | Reuses Iframe | Perceived Load Speed | Notes
| Normal Render | ❌ | ✅ No | ✅ No | ❌ | ❌ Slowest | No reuse; re-renders every time
| Prefetch | ✅ (few assets) | ✅ No | ⚠️ Yes (small assets) | ❌ | ⚠️ Slight improvement | Browser cache often makes it redundant
| Prerender + ID | ✅ | ❌ Yes | ❌ Yes | ✅ | ✅✅✅ Fastest | Best UX, worst resource efficiency
| Prerender w/o ID | ✅ | ✅ No | ⚠️ Yes (partial assets) | ✅ | ⚠️ Moderate | Trade-off between prep and efficiency
| On Demand | ❌ | ✅ No | ✅ No | ✅ | ✅ (on revisit), ❌ (first visit) | Best balance of performance and efficiency
|===

== How to Implement Pre-rendering

You can use pre-rendering in both standard JavaScript and React. Here are the key methods and properties from the Visual Embed SDK:

[cols="1,2,2",options="header"]
|===
| Method/Property | Description | Example
| preRender() | Creates a pre-render shell | `await embed.preRender();`
| prerenderGeneric() | Pre-renders a generic instance | `await embed.prerenderGeneric();`
| showPreRender() | Displays the pre-rendered component | `await embed.showPreRender();`
| hidePreRender() | Hides the pre-rendered component | `embed.hidePreRender();`
| getPreRenderIds() | Gets unique HTML element IDs for pre-render elements | `embed.getPreRenderIds();`
| preRenderId | Config property for the pre-rendered instance | `preRenderId: "preRenderId-123"`
| syncPreRenderStyle() | Syncs style/position/size with the embedding element | `embed.syncPreRenderStyle();`
| doNotTrackPreRenderSize | Disables dynamic size tracking | `doNotTrackPreRenderSize: true`
|===

== Troubleshooting

* If the pre-rendered component does not appear, check that the container is visible and coordinates are set.
* Ensure you are not re-creating the embed instance on every render in React.

== Additional Resources

* link:https://github.com/thoughtspot/developer-examples/tree/main/visual-embed/pre-rendering[Pre-rendering examples on GitHub]
* link:https://codesandbox.io/p/sandbox/github/thoughtspot/developer-examples/tree/main/visual-embed/pre-rendering[CodeSandbox: Pre-rendering]

