= Pre-rendering ThoughtSpot Embed Components
:toc: true
:toclevels: 3

:page-title: Pre-rendering for Fast Embeds
:page-pageid: prerender
:page-description: How to use pre-rendering to optimize performance and user experience in ThoughtSpot embedding

+== Load Flow Diagrams
+
+The following diagrams illustrate how ThoughtSpot embed components load in a typical application, both for normal and pre-rendered scenarios. Reviewing these will help set the context for the strategies described in this guide.
+
+image::./images/pre-render/embed_load.png[]
+image::./images/pre-render/liveboardEmbed_load.png[]

== How Embedding Normally Works (The Basics)

When you embed ThoughtSpot (or any analytics app) in your application, the typical flow is:

. The user navigates to a page with the embed component.
. The embed component is rendered in the DOM.
. The browser loads the ThoughtSpot iframe and all required assets (JS, CSS, etc).
. The iframe initializes, fetches data, and finally displays the analytics.

This means *every time* a user visits the page, the iframe and all assets are loaded from scratch, causing a visible delay before analytics appear.

image::./images/pre-render/embed_load.png[]

== What is Pre-rendering?

Pre-rendering changes this flow by *loading some or all of the assets and initialization steps in the background*, before the user actually navigates to the analytics. This way, when the user visits the page, the analytics are ready to show instantly (or much faster).

[NOTE]
====
Pre-rendering is most effective when your application has a loading page, landing page, or pre-embed page where you can start the pre-render process before the user navigates to the analytics. If a user navigates directly to the embed page (for example, via a direct link or bookmark), pre-rendering cannot provide a speed benefit because there is no opportunity to load assets in advance.
====

Pre-rendering can preload just the common assets, or even a specific liveboard, depending on your needs. The rest of this doc explains the different strategies and how to use them.

Pre-rendering lets you load ThoughtSpot embed components in the background, so users see analytics instantly when they navigate to them. This doc explains the different pre-render strategies, when to use each, and how to implement them in React or JavaScript.

== Why Pre-render?

* Reduce wait times for embedded analytics
* Improve perceived performance and user experience
* Choose the right tradeoff between speed and resource usage

== Embed Load Strategies

=== 1. Prerender with Liveboard ID

- Fully loads the embed iframe, including all assets and liveboard data, as soon as the component is rendered.
- Fastest experience for a specific liveboard.
- Maximum resource usage if the user never views the embed.

To use this strategy, place the following component on your application's home page, loading page, or landing page (before the user navigates to the analytics):

[source,jsx]
----
<PreRenderedLiveboardEmbed
  liveboardId="e40c0727-01e6-49db-bb2f-5aa19661477b"
  preRenderId="pre-render-with-liveboard-id"
/>
----

The value of `preRenderId` can be any string, but it must match the `preRenderId` you use when rendering the actual embed later.

[NOTE]
====
Limitation: Any props you want to pass to the embed (such as configuration options) must be passed to the `PreRenderedLiveboardEmbed` component on the home page. If you later render a `LiveboardEmbed` with the same `preRenderId`, those new props will not be respected if the iframe is already loaded. This is a current limitation of the pre-rendering approach.
====

.React Example
[source,jsx]
----
import { LiveboardEmbed } from "@thoughtspot/visual-embed-sdk/react";

const PreRenderLiveboardWithLiveboardId = () => (
  <LiveboardEmbed
    preRenderId="pre-render-with-liveboard-id"
    liveboardId="e40c0727-01e6-49db-bb2f-5aa19661477b"
    className="embed-div"
  />
);
----

image::./images/pre-render/pre_render_with_liveboard_id.png[]

=== 2. Prerender without Liveboard ID

- Loads common assets and bootstrap logic early.
- Defers liveboard-specific data/API calls until needed.
- Keeps the app ready, making the first liveboard load faster.
- Still loads some assets even if the user never opens the embed.

To use this strategy, place the following component on your application's home page, loading page, or landing page:

[source,jsx]
----
<PreRenderedLiveboardEmbed
  preRenderId="pre-render-without-liveboard-id"
/>
----

Again, the value of `preRenderId` can be any string, but it must match the `preRenderId` you use when rendering the actual embed later.

[NOTE]
====
Limitation: Any props you want to pass to the embed must be passed to the `PreRenderedLiveboardEmbed` component on the home page. If you later render a `LiveboardEmbed` with the same `preRenderId`, those new props will not be respected if the iframe is already loaded.
====

.React Example
[source,jsx]
----
import { LiveboardEmbed } from "@thoughtspot/visual-embed-sdk/react";

const PreRenderLiveboardWithoutLiveboardId = () => (
  <LiveboardEmbed
    preRenderId="pre-render-without-liveboard-id"
    liveboardId="e40c0727-01e6-49db-bb2f-5aa19661477b"
    className="embed-div"
  />
);
----

image::./images/pre-render/prerender_without_liveboard_id.png[]

=== 3. Prerender On Demand

- Loads nothing up front; the embed is loaded only when the user navigates to it.
- On first visit, the embed loads normally; on return, the iframe is reused and appears instantly.
- Most efficient; only loads if needed, and reuses the iframe for instant reloads.

When you render a component with a `preRenderId` for the first time, it loads as usual. The next time you render a component with the same `preRenderId`, the load is instant because the iframe is reused.

This strategy does not require special configuration—simply pass a `preRenderId` prop to your normal component render:

[source,jsx]
----
<LiveboardEmbed preRenderId="pre-render-on-demand" className="embed-div" />
----

.React Example
[source,jsx]
----
import { LiveboardEmbed } from "@thoughtspot/visual-embed-sdk/react";

const PreRenderEmbedOnDemand = () => (
  <LiveboardEmbed preRenderId="pre-render-on-demand" className="embed-div" />
);
----

image::./images/pre-render/preRender_on_demand.png[]

=== 4. Normal Render

- Default behavior; loads the embed only when the component is rendered.
- On every visit, the iframe is recreated and the embed loads from scratch.
- Efficient if the embed is rarely used, but slow for the user every time.

.React Example
[source,jsx]
----
import { AppEmbed } from "@thoughtspot/visual-embed-sdk/react";

const NormalEmbed = () => <AppEmbed className="embed-div" />;
----

image::./images/pre-render/normal_embed_load.png[]

=== 5. Prefetch

- Loads a few common JS/CSS assets in parallel with your app.
- No liveboard data or API calls are made.
- Minimal benefit (modern browsers cache these assets anyway).
- Wastes bandwidth if the user never opens the embed.

[NOTE]
====
Prefetch is generally not recommended unless you have a specific need, as modern browsers already cache static assets efficiently. Using prefetch may result in unnecessary network usage without significant performance gain.
====

.Example: Prefetching assets
[source,js]
----
import {
   prefetch,
   PrefetchFeatures
} from '@thoughtspot/visual-embed-sdk';

prefetch("https://<hostname>:<port>", [
  PrefetchFeatures.LiveboardEmbed,
  PrefetchFeatures.VizEmbed
]);

init({
  thoughtSpotHost: "https://<hostname>:<port>",
  authType: AuthType.None,
});
----

image::./images/pre-render/preFetch.png[]

== Strategy Comparison Table

[cols="1,1,1,1,1,1,2",options="header"]
|===
| Strategy | Loads in Parallel | Loads Data If Not Used | Loads Assets If Not Used | Reuses Iframe | Perceived Load Speed | Notes
| Normal Render | ❌ | ✅ No | ✅ No | ❌ | ❌ Slowest | No reuse; re-renders every time
| Prefetch | ✅ (few assets) | ✅ No | ⚠️ Yes (small assets) | ❌ | ⚠️ Slight improvement | Browser cache often makes it redundant
| Prerender + ID | ✅ | ❌ Yes | ❌ Yes | ✅ | ✅✅✅ Fastest | Best UX, worst resource efficiency
| Prerender w/o ID | ✅ | ✅ No | ⚠️ Yes (partial assets) | ✅ | ⚠️ Moderate | Trade-off between prep and efficiency
| On Demand | ❌ | ✅ No | ✅ No | ✅ | ✅ (on revisit), ❌ (first visit) | Best balance of performance and efficiency
|===

== How to Implement Pre-rendering

You can use pre-rendering in both standard JavaScript and React. Here are the key methods and properties from the Visual Embed SDK:

[cols="1,2,2",options="header"]
|===
| Method/Property | Description | Example
| preRender() | Creates a pre-render shell | `await embed.preRender();`
| prerenderGeneric() | Pre-renders a generic instance | `await embed.prerenderGeneric();`
| showPreRender() | Displays the pre-rendered component | `await embed.showPreRender();`
| hidePreRender() | Hides the pre-rendered component | `embed.hidePreRender();`
| getPreRenderIds() | Gets unique HTML element IDs for pre-render elements | `embed.getPreRenderIds();`
| preRenderId | Config property for the pre-rendered instance | `preRenderId: "preRenderId-123"`
| syncPreRenderStyle() | Syncs style/position/size with the embedding element | `embed.syncPreRenderStyle();`
| doNotTrackPreRenderSize | Disables dynamic size tracking | `doNotTrackPreRenderSize: true`
|===

== Troubleshooting

* If the pre-rendered component does not appear, check that the container is visible and coordinates are set.
* Ensure you are not re-creating the embed instance on every render in React.

== Additional Resources

* link:https://github.com/thoughtspot/developer-examples/tree/main/visual-embed/pre-rendering[Pre-rendering examples on GitHub]
* link:https://codesandbox.io/p/sandbox/github/thoughtspot/developer-examples/tree/main/visual-embed/pre-rendering[CodeSandbox: Pre-rendering]

