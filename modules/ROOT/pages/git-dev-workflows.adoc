= Advanced Git workflows
:toc: true
:toclevels: 2

:page-title: Advanced Git workflows
:page-pageid: git-dev-workflows
:page-description: The version control APIs allow for a variety of workflows to integrate with your SDLC practices

The Git integration APIs within ThoughtSpot are designed to flexibly support a variety of workflows similar to what you might encounter in software development environment.  There are limitations.  In general, you should consider the Git integration approach to be one-way, that is, from Dev to Test to Production.  Withing these constraints, however, there are a few common patterns that often occur.

== Overview of TML and version control

Unless you are doing specific programmatic activities directly using ThoughtSpot Modeling Language (TML), the vast majority of "building" in ThoughtSpot happens within the ThoughtSpot application. Version control is then supported via a few different ways.

* If you just want to version control liveboards or answers within an org, you can use the Version Control features available via the UI.  
* If you use GitHub or other supported VCS tools, you can use the version control APIs.  
* If you cannot use a suppoted VCS tool, then you can use TML import and export along with your version control system.

For information on using the build-in version control system for liveboards and answers see the [documentation](https://docs.thoughtspot.com/cloud/latest/git-version-control).  The following sections will discuss using TML import and export, and Git Version control.

== TML Import and Export



== Version control with Git

TML files can be 
TML files can be uploaded directly via the UI, using the Metadata TML import API (https://developers.thoughtspot.com/docs/rest-apiv2-reference#_metadata) or via the VCS Git Commits Deploy API (https://developers.thoughtspot.com/docs/rest-apiv2-reference#_version_control). The UI or TML Import API the correct way to introduce a new TML file or do an update into the dev Org, with the Git Commit API taking care of recording the changes down into the dev branch afterwards. 


You can use any number of branches for your "dev environment", as long as you merge them together into a *single* branch that gets merged into the branches linked to the later environments (test, uat, prod)







The main principles to remember are:

 1. The dev Org in ThoughtSpot is the "source of truth" for the dev environment, not the dev branch. The dev branch is the "source of truth" for other environments that use the Deploy API
 2. Each Org can be configured to be aware of any number of Git branches in a single repository for the purpose of committing to
 3. Commit API specifies individual objects to commit and the Git branch 
 4. Merging changes between branches is controlled entirely through Git actions like pull requests and merges
 5. Deploy API deploys *all* files found within a branch to an Org

Multiple "dev environments"
The "dev-test-prod" simplified model may be extended along a number of lines when ThoughtSpot is supporting mutiple development teams.

If you have fully separated product teams, each team maybe have their own fully parallel set of dev-test-prod environments.

Branch per developer patterns

Feature branches pattern
A common Git pattern is to create a new branch for every single "feature".

Because each Org requires a Configure API action to be made aware of a branch, it is difficult to directly commit to an arbitrary unknown branch. 

If you are


Deploying back into dev Org
