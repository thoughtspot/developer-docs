= Advanced Git workflows
:toc: true
:toclevels: 2

:page-title: Advanced Git workflows
:page-pageid: git-dev-workflows
:page-description: The version control APIs allow for a variety of workflows to integrate with your SDLC practices

The Git integration APIs within ThoughtSpot are designed to flexibly support a variety of workflows similar to what you might encounter in software development environment.  There are limitations.  In general, you should consider the Git integration approach to be one-way, that is, from Dev to Test to Production.  Withing these constraints, however, there are a few common patterns that often occur.

== Overview of TML and version control

Unless you are doing specific programmatic activities directly using ThoughtSpot Modeling Language (TML), the vast majority of "building" in ThoughtSpot happens within the ThoughtSpot application. 

Version control is then supported via a few different ways.

* If you just want to version control liveboards or answers within an org, you can use the link:https://docs.thoughtspot.com/cloud/latest/git-version-control[Version Control features available via the UI].  
* If you use GitHub or other supported Version Control System (VCS) tool, you can use the xref:version_control.adoc[version control APIs].  
* If you cannot use a supported VCS tool, then you can build your own process using the xref:deploy-with-tml-apis.adoc[TML import and export APIs] along with your version control system.

The following sections will discuss using TML import and export, and Git version control.

=== TML Import and Export

TML can be exported from ThoughtSpot using the link:https://developers.thoughtspot.com/docs/rest-apiv2-reference#_metadata[metadata/tml/export API] and then imported using the link:https://developers.thoughtspot.com/docs/rest-apiv2-reference#_metadata[metadata/tml/import API].  The files can then be managed locally or in an online VCS.  

There are a few considerations when using these APIs:

* The user is responsible for export, storage, and import.  Adding or getting files from the VCS is external to ThoughtSpot.  
* If the user migrates files from one environment, such as Dev, to another, such as Prod, then the user is responsible for GUID mapping between environments.  

An advantage of this approach is that that TML files can be imported back into the same environment from which they were exported.

If you are going to use this approach, you may want to consider the link:https://thoughtspot.github.io/cs_tools/tools/scriptability/[CS Tools Scriptability] tool, which has built in tools for managing the export, GUID mapping, and import process.  

=== Version control with Git

The Git APIs were introduced to help reduce the complexity of managing the migration of content between orgs and instances.  The remainder of this document will talk about orgs, but the same principals apply for separate instances.  

In general, Git APIs are used when wanting to have an SDLC type of environment in which content is created in a development, migrated to test, and then deployed into production.  There are variations for different users, but this is the general scenario.  The examples will flow from simple, to more complex scenarios, but all will follow the same patter of dev -> test -> prod.

There are keys to consider when setting up this type of environment:

* The should be *one* source of truth for content.  If you have dev -> test -> prod, all changes should originate from dev.
* Orgs can be configured to write (commit) or read (deploy) from multiple branches.  But a given branch cannot be shared across orgs.
* GUIDs are unique across orgs, meaning a mapping approach is required to keep the relationship between TML objects.  It is planned to have changes in the future that allow GUIDs to be unique at the org level and therefore they can be the same across orgs.
* Moving content between branches in the VCS system is done in the VCS systems, such as doing pull requests and merges in GitHub.
* Commits can be specied at the individual object level, but deploys are at the branch level.  I.e. you can commit a single file, but when deploying either all files or all changed files will be deployed.

== Deployment Patterns

There are a few common deployment patterns that will be covered here:

* Simple dev -> test -> prod
* Dev -> test -> multiple prod
* Multiple dev -> multiple test -> multiple prod

=== Simple dev -> test -> prod

The most basic flow is to have separate environments for development, test, and production.  This approach is similar to most software development environments.  A major difference with software is that the content is edited in a common environment, i.e. the develop org in ThoughtSpot, instead of locally and then merged into a common develop branch.  

In this scenario, GitHub has three orgs and three branches:

* Develop or with associated develop branch in GitHub.  The develop org is configured to commit to the develop branch.  Content doesn't have to be all commited to GitHub at the same time, but it all ends up in the same branch.
* The test org and test branch are for validation and user acceptance tests.  This is content and results are verified.  As content is ready in the develop branch, it is merged into the test branch and then deployed to the Test org, where testing occurs.  If errors are discovered, *_they are fixed in the develop branch_* and migrate from Dev to Test again.
* Finally there is the production branch that end users use for analytics.  Users can request additional content and changes to existing content that is managed in via the develop process.  Users may also create content that builds on the "official" content.

=== Dev -> test -> multiple prod

This scenario is like dev and test except there are multiple production targets.  In this scenario we are assuming that all production environnements get all or some of the conten from develop and test.

Dev and test follow the same steps as with the dev -> test flow.  What changes is the flow to production.  Typically all content from test is moved to all production branches.  However, it's possible to move only some content.  This increases complexity since you need to track content to the specific object level.  For that reason, it may be more appropriate to use the content below for scenarios where subsets of content are being deployed to production.

=== Multiple dev -> multiple test -> multiple prod

== Other considerations

Cover the other topics:

* User created content that creates dependencies.
* Customizations for customer orgs (e.g. column names, slightly different versions of content, etc.)
