= Advanced Git workflows
:toc: true
:toclevels: 2

:page-title: Advanced Git workflows
:page-pageid: git-dev-workflows
:page-description: The version control APIs allow for a variety of workflows to integrate with your SDLC practices

The Git integration APIs within ThoughtSpot are designed to flexibly support a variety of workflows similar to what you might encounter in software development environment.  There are limitations.  In general, you should consider the Git integration approach to be one-way, that is, from Dev to Test to Production.  Withing these constraints, however, there are a few common patterns that often occur.

== Overview of TML and version control

Unless you are doing specific programmatic activities directly using ThoughtSpot Modeling Language (TML), the vast majority of "building" in ThoughtSpot happens within the ThoughtSpot application. Version control is then supported via a few different ways.

* If you just want to version control liveboards or answers within an org, you can use the Version Control features available via the UI.  
* If you use GitHub or other supported Version Control System (VCS) tool, you can use the version control APIs.  
* If you cannot use a supported VCS tool, then you can use TML import and export along with your version control system.

For information on using the build-in version control system for liveboards and answers see the [documentation](https://docs.thoughtspot.com/cloud/latest/git-version-control).  The following sections will discuss using TML import and export, and Git Version control.

=== TML Import and Export

TML can be exported from ThoughtSpot using the [metadata/tml/export](https://developers.thoughtspot.com/docs/rest-apiv2-reference#_metadata) API and then imported using the [metadata/tml/import](https://developers.thoughtspot.com/docs/rest-apiv2-reference#_metadata) API.  The files can then be managed locally or in an online VCS.  There are a few considerations when using these APIs:

* The user is responsible for export, storage, and import.  Adding or getting files from the VCS is external to ThoughtSpot.  
* If the user migrates files from one environment, such as Dev, to another, such as Prod, then the user is responsible for GUID mapping between environments.  

An advantage of this approach is that that TML files can be imported back into the same environment from which they were exported.

If you are going to use this approach, you may want to consider [CS Tools Scriptability](https://thoughtspot.github.io/cs_tools/tools/scriptability/), which can help with the export, mapping, and import.  

=== Version control with Git

The Git APIs were introduced to help reduce the complexity of managing the migration of content between orgs and instances.  The remainder of this document will talk about orgs, but the same principals apply for separate instances.  

In general, Git APIs are used when wanting to have an SDLC type of environment in which content is created in a development, migrated to test, and then deployed into production.  There are variations for different users, but this is the general scenario.  The examples will flow from simple, to more complex scenarios, but all will follow the same patter of dev -> test -> prod.

There are keys to consider when setting up this type of environment:

* The should be *one* source of truth for content.  If you have dev -> test -> prod, all changes should originate from dev.
* Orgs can be configured to write (commit) or read (deploy) from multiple branches.  But a given branch cannot be shared across orgs.
* GUIDs are unique across orgs, meaning a mapping approach is required to keep the relationship between TML objects.  It is planned to have changes in the future that allow GUIDs to be unique at the org level and therefore they can be the same across orgs.
* Moving content between branches in the VCS system is done in the VCS systems, such as doing pull requests and merges in GitHub.
* Commits can be specied at the individual object level, but deploys are at the branch level.  I.e. you can commit a single file, but when deploying either all files or all changed files will be deployed.

== Deployement Patterns

There are a few common deployment patterns that will be covered here:

* Simple dev -> test -> prod
* Dev -> test -> multiple prod
* Multiple dev -> multiple test -> multiple prod

=== Simple dev -> test -> prod

=== Dev -> test -> multiple prod


=== Multiple dev -> multiple test -> multiple prod
